<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Ping-Frequenz-Analyzer</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      max-width: 900px;
      margin: 2rem auto;
      padding: 0 1rem;
    }
    h1 {
      font-size: 1.6rem;
      margin-bottom: 0.5rem;
    }
    .card {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 1rem 1.2rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    label {
      font-weight: 600;
    }
    input[type="file"] {
      margin-top: 0.3rem;
    }
    button {
      margin-top: 0.8rem;
      padding: 0.4rem 0.8rem;
      border-radius: 4px;
      border: 1px solid #888;
      background: #f0f0f0;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    #status {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #444;
      white-space: pre-line;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.8rem;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 0.3rem 0.4rem;
      text-align: right;
      font-size: 0.9rem;
    }
    th {
      background: #f7f7f7;
    }
    td:first-child, th:first-child {
      text-align: center;
    }
    #log {
      font-family: monospace;
      font-size: 0.8rem;
      color: #555;
      margin-top: 0.5rem;
      white-space: pre-wrap;
    }
    #spectrumCanvas {
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-top: 0.5rem;
      width: 100%;
      max-width: 800px;
      height: 300px;
    }
    #peakControls {
      margin-top: 0.6rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    #peakInfo {
      font-size: 0.9rem;
      color: #333;
    }
    #logScaleContainer {
      margin-top: 0.4rem;
      font-size: 0.9rem;
    }
    #logScaleContainer input {
      margin-right: 0.3rem;
    }
  </style>
</head>
<body>
  <h1>Ping-Frequenz-Analyzer (Top 10 Peaks)</h1>

  <div class="card">
    <label for="fileInput">Audio-Datei wählen (wav, m4a, mp3, flac …):</label><br>
    <input id="fileInput" type="file" accept=".wav,.wave,.m4a,.mp3,.flac,audio/*">
    <br>
    <button id="analyzeBtn" disabled>Analyse starten</button>
    <button id="exportBtn" disabled>Export TXT</button>
    <div id="status">Noch keine Datei geladen.</div>
    <div id="log"></div>
  </div>

  <div class="card">
    <h2>Spektrum (Amplitude in dB, ab 50 Hz)</h2>
    <div id="logScaleContainer">
      <label>
        <input type="checkbox" id="logScaleToggle">
        Logarithmische Frequenzachse
      </label>
    </div>
    <canvas id="spectrumCanvas" width="800" height="300"></canvas>
    <div id="peakControls">
      <button id="prevPeakBtn" disabled>◀ Peak</button>
      <button id="nextPeakBtn" disabled>Peak ▶</button>
      <div id="peakInfo">Noch keine Peaks.</div>
    </div>
  </div>

  <div class="card">
    <h2>Signifikanteste Frequenzen (Top 10)</h2>
    <table>
      <thead>
        <tr>
          <th>#</th>
          <th>Frequenz [Hz]</th>
          <th>Amplitude (rel.)</th>
        </tr>
      </thead>
      <tbody id="resultsBody">
        <tr><td colspan="3" style="text-align:center;">Noch keine Analyse durchgeführt.</td></tr>
      </tbody>
    </table>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const statusEl = document.getElementById('status');
    const resultsBody = document.getElementById('resultsBody');
    const logEl = document.getElementById('log');

    const spectrumCanvas = document.getElementById('spectrumCanvas');
    const ctx = spectrumCanvas.getContext('2d');
    const prevPeakBtn = document.getElementById('prevPeakBtn');
    const nextPeakBtn = document.getElementById('nextPeakBtn');
    const peakInfoEl = document.getElementById('peakInfo');
    const exportBtn = document.getElementById('exportBtn');
    const logScaleToggle = document.getElementById('logScaleToggle');

    let audioBufferGlobal = null;
    let sampleRateGlobal = null;

    // {magnitudes, minBin, maxBin, N, sr, maxMag, minFreq, maxFreq, windowStartSample}
    let spectrumData = null;
    let peaksList = [];           // [{freq, mag, relAmp}]
    let currentPeakIndex = -1;
    let loadedFileName = null;

    const MIN_FREQ_HZ = 50;    // Analyse ab 50 Hz
    const NUM_PEAKS = 10;       // Anzahl signifikantester Peaks
    const MIN_DB = -80;         // unter -80 dB wird abgeschnitten
    const GATE_OFFSET_MS = 10;  // Fenster beginnt 10 ms nach dem Schlag

    let useLogScale = false;

    fileInput.addEventListener('change', handleFileChange);
    analyzeBtn.addEventListener('click', analyzeSpectrum);
    exportBtn.addEventListener('click', exportData);
    prevPeakBtn.addEventListener('click', () => selectPeak(currentPeakIndex - 1));
    nextPeakBtn.addEventListener('click', () => selectPeak(currentPeakIndex + 1));
    spectrumCanvas.addEventListener('click', handleCanvasClick);
    logScaleToggle.addEventListener('change', () => {
      useLogScale = logScaleToggle.checked;
      drawSpectrum();
    });

    function appendLog(msg) {
      logEl.textContent += msg + "\n";
    }

    async function handleFileChange(e) {
      const file = e.target.files[0];
      if (!file) {
        analyzeBtn.disabled = true;
        statusEl.textContent = "Noch keine Datei geladen.";
        return;
      }
      statusEl.textContent = "Lade und dekodiere Audio …";
      logEl.textContent = "";
      resetAnalysis();

      const reader = new FileReader();
      reader.onload = async (ev) => {
        const arrayBuffer = ev.target.result;
        try {
          const AudioCtx = window.AudioContext || window.webkitAudioContext;
          const audioCtx = new AudioCtx();

          const audioBuffer = await new Promise((resolve, reject) => {
            audioCtx.decodeAudioData(
              arrayBuffer.slice(0),
              decoded => resolve(decoded),
              err => reject(err)
            );
          });

          audioBufferGlobal = audioBuffer;
          sampleRateGlobal = audioBuffer.sampleRate;
          loadedFileName = file.name;
          const dur = audioBuffer.duration.toFixed(2);
          statusEl.textContent = `Geladen: ${file.name}\nLänge: ${dur} s, Abtastrate: ${sampleRateGlobal} Hz`;
          appendLog(`Kanäle: ${audioBuffer.numberOfChannels}`);
          analyzeBtn.disabled = false;
          audioCtx.close();
        } catch (err) {
          console.error(err);
          statusEl.textContent = "Fehler beim Dekodieren des Audios.";
          analyzeBtn.disabled = true;
        }
      };
      reader.readAsArrayBuffer(file);
    }

    function resetAnalysis() {
      spectrumData = null;
      peaksList = [];
      currentPeakIndex = -1;
      drawEmptySpectrum();
      resultsBody.innerHTML = '<tr><td colspan="3" style="text-align:center;">Noch keine Analyse durchgeführt.</td></tr>';
      peakInfoEl.textContent = "Noch keine Peaks.";
      prevPeakBtn.disabled = true;
      nextPeakBtn.disabled = true;
      exportBtn.disabled = true;
    }

    function analyzeSpectrum() {
      if (!audioBufferGlobal) {
        statusEl.textContent = "Bitte zuerst eine Datei laden.";
        return;
      }
      try {
        const channelData = audioBufferGlobal.getChannelData(0);
        const sr = sampleRateGlobal;
        const totalLen = channelData.length;

        const maxN = 65536;
        const maxLen = Math.min(maxN, totalLen);
        let N = 1;
        while ((N << 1) <= maxLen) {
          N <<= 1;
        }

        // stärksten Impuls (Schlag) finden
        let maxIdx = 0;
        let maxAbs = 0;
        for (let i = 0; i < totalLen; i++) {
          const v = Math.abs(channelData[i]);
          if (v > maxAbs) {
            maxAbs = v;
            maxIdx = i;
          }
        }

        // Fenster NICHT um den Schlag zentrieren,
        // sondern NACH dem Schlag starten (Gate)
        const gateOffsetSamples = Math.floor(sr * (GATE_OFFSET_MS / 1000));
        let start = maxIdx + gateOffsetSamples;
        if (start + N > totalLen) start = totalLen - N;
        if (start < 0) start = 0;

        appendLog(`Verwende Fensterlänge N=${N}, Startindex=${start}, Peakindex=${maxIdx}, Offset=${gateOffsetSamples} Samples`);

        const real = new Float32Array(N);
        const imag = new Float32Array(N);
        const twoPi = 2 * Math.PI;
        for (let i = 0; i < N; i++) {
          const x = channelData[start + i];
          const w = 0.5 * (1 - Math.cos(twoPi * i / (N - 1))); // Hann-Fenster
          real[i] = x * w;
          imag[i] = 0;
        }

        fft(real, imag);

        const halfN = N >> 1;
        const magnitudes = new Float32Array(halfN);
        for (let k = 0; k < halfN; k++) {
          const re = real[k];
          const im = imag[k];
          magnitudes[k] = Math.hypot(re, im);
        }

        const minBin = Math.floor(MIN_FREQ_HZ * N / sr);
        const maxBin = halfN - 1;
        const minFreq = MIN_FREQ_HZ;
        const maxFreq = (maxBin * sr) / N;

        // Maximalwert nur im angezeigten Bereich
        let displayMaxMag = 0;
        for (let k = minBin; k <= maxBin; k++) {
          if (magnitudes[k] > displayMaxMag) displayMaxMag = magnitudes[k];
        }

        spectrumData = {
          magnitudes,
          minBin,
          maxBin,
          N,
          sr,
          maxMag: displayMaxMag,
          minFreq,
          maxFreq,
          windowStartSample: start
        };

        // Peaks suchen (Top NUM_PEAKS, mit Mindestabstand)
        const peaks = [];
        for (let k = minBin; k <= maxBin; k++) {
          peaks.push({ bin: k, mag: magnitudes[k] });
        }
        peaks.sort((a, b) => b.mag - a.mag);

        const rawSelected = [];
        const takenFreqs = [];
        const freqTolerance = 200; // Hz Mindestabstand

        for (let i = 0; i < peaks.length && rawSelected.length < NUM_PEAKS; i++) {
          const k = peaks[i].bin;
          const f = k * sr / N;
          const mag = peaks[i].mag;
          if (mag <= 0) continue;

          let tooClose = false;
          for (const f0 of takenFreqs) {
            if (Math.abs(f - f0) < freqTolerance) {
              tooClose = true;
              break;
            }
          }
          if (tooClose) continue;

          rawSelected.push({ freq: f, mag: mag });
          takenFreqs.push(f);
        }

        if (rawSelected.length === 0) {
          peaksList = [];
          resultsBody.innerHTML = '<tr><td colspan="3" style="text-align:center;">Keine signifikanten Peaks gefunden.</td></tr>';
          peakInfoEl.textContent = "Keine Peaks gefunden.";
          prevPeakBtn.disabled = true;
          nextPeakBtn.disabled = true;
        } else {
          rawSelected.sort((a, b) => a.freq - b.freq);
          const maxMagSel = rawSelected.reduce((m, p) => p.mag > m ? p.mag : m, 0);
          peaksList = rawSelected.map(p => ({
            freq: p.freq,
            mag: p.mag,
            relAmp: p.mag / maxMagSel
          }));

          let rows = "";
          peaksList.forEach((p, idx) => {
            rows += `<tr>
              <td>${idx + 1}</td>
              <td>${p.freq.toFixed(1)}</td>
              <td>${p.relAmp.toFixed(3)}</td>
            </tr>`;
          });
          resultsBody.innerHTML = rows;

          currentPeakIndex = 0;
          prevPeakBtn.disabled = peaksList.length <= 1;
          nextPeakBtn.disabled = peaksList.length <= 1;
          updatePeakInfo();
        }

        drawSpectrum();
        statusEl.textContent += `\nAnalyse fertig.`;
        exportBtn.disabled = false;
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Fehler bei der Analyse.";
      }
    }

    function exportData() {
      if (!audioBufferGlobal || !spectrumData) {
        alert("Bitte zuerst eine Analyse durchführen.");
        return;
      }

      const { N, minFreq, maxFreq, windowStartSample } = spectrumData;

      const fileName = loadedFileName || "ping";
      const baseName = fileName.replace(/\.[^/.]+$/, "");

      const reportLines = [];
      reportLines.push("Ping-Analyzer Report");
      reportLines.push("====================");
      reportLines.push(`Datei: ${loadedFileName || "Unbekannt"}`);
      reportLines.push(`Sample-Rate: ${sampleRateGlobal} Hz`);
      reportLines.push(`Dauer: ${audioBufferGlobal.duration.toFixed(3)} s`);
      reportLines.push(`Kanal: 0 von ${audioBufferGlobal.numberOfChannels}`);
      reportLines.push("");
      reportLines.push("Analyse-Parameter");
      reportLines.push("-----------------");
      reportLines.push(`FFT-Länge: ${N}`);
      reportLines.push("Fenster: Hann");
      reportLines.push(`Fensterstart (Sample): ${windowStartSample != null ? windowStartSample : "n/a"}`);
      reportLines.push(`Gate-Offset: ${GATE_OFFSET_MS} ms`);
      reportLines.push(`Frequenzbereich: ${minFreq.toFixed(1)} - ${maxFreq.toFixed(1)} Hz`);
      reportLines.push(`dB-Floor: ${MIN_DB} dB`);
      reportLines.push(`x-Achse: ${useLogScale ? "logarithmisch" : "linear"}`);
      reportLines.push("");
      reportLines.push("Top-Peaks");
      reportLines.push("---------");
      if (!peaksList.length) {
        reportLines.push("Keine Peaks gefunden.");
      } else {
        reportLines.push("#  Freq [Hz]   rel. Amp   dB");
        peaksList.forEach((p, idx) => {
          const rank = idx + 1;
          const freqStr = p.freq.toFixed(1).padStart(9, " ");
          const relStr = p.relAmp.toFixed(3).padStart(9, " ");
          const dbVal = p.relAmp > 0 ? 20 * Math.log10(p.relAmp) : MIN_DB;
          const dbStr = dbVal.toFixed(1).padStart(7, " ");
          reportLines.push(`${rank.toString().padStart(2, " ")}  ${freqStr}  ${relStr}  ${dbStr}`);
        });
      }
      const reportStr = reportLines.join("\n");
      downloadText(reportStr, baseName + ".ping.txt", "text/plain");
    }

    function downloadText(textContent, fileName, mimeType) {
      const blob = new Blob([textContent], { type: mimeType || "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function drawEmptySpectrum() {
      const w = spectrumCanvas.width;
      const h = spectrumCanvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#fafafa";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#999";
      ctx.font = "12px system-ui";
      ctx.fillText("Noch kein Spektrum vorhanden.", 10, 20);
    }

    // Helper: Frequenz ↔︎ [0..1] (je nach Skala)
    function freqToFrac(freq, minFreq, maxFreq) {
      if (freq < minFreq) freq = minFreq;
      if (freq > maxFreq) freq = maxFreq;
      if (!useLogScale) {
        return (freq - minFreq) / (maxFreq - minFreq);
      } else {
        const safeMin = Math.max(minFreq, 1e-3);
        const logMin = Math.log10(safeMin);
        const logMax = Math.log10(maxFreq);
        const logF  = Math.log10(Math.max(freq, safeMin));
        return (logF - logMin) / (logMax - logMin);
      }
    }

    function fracToFreq(frac, minFreq, maxFreq) {
      if (frac < 0) frac = 0;
      if (frac > 1) frac = 1;
      if (!useLogScale) {
        return minFreq + frac * (maxFreq - minFreq);
      } else {
        const safeMin = Math.max(minFreq, 1e-3);
        const logMin = Math.log10(safeMin);
        const logMax = Math.log10(maxFreq);
        const logF = logMin + frac * (logMax - logMin);
        return Math.pow(10, logF);
      }
    }

    // Tick-Frequenzen für die x-Achse (log-freundliche Werte)
    function getTickFrequencies(minFreq, maxFreq) {
      const baseTicks = [
        50, 100, 200, 500,
        1000, 2000, 5000,
        10000, 20000
      ];
      return baseTicks.filter(f => f > minFreq * 1.001 && f < maxFreq * 0.999);
    }

    function formatHzLabel(f) {
      if (f < 1000) return `${Math.round(f)} Hz`;
      if (f < 10000) return `${(f / 1000).toFixed(1)} kHz`;
      return `${(f / 1000).toFixed(0)} kHz`;
    }

    function drawSpectrum() {
      const w = spectrumCanvas.width;
      const h = spectrumCanvas.height;
      ctx.clearRect(0, 0, w, h);

      if (!spectrumData) {
        drawEmptySpectrum();
        return;
      }

      const { magnitudes, minBin, maxBin, N, sr, maxMag, minFreq, maxFreq } = spectrumData;

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, w, h);

      const padX = 40;
      const padY = 20;
      const plotW = w - 2 * padX;
      const plotH = h - 2 * padY;

      // Achsen
      ctx.strokeStyle = "#ccc";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padX, h - padY);
      ctx.lineTo(padX + plotW, h - padY);
      ctx.moveTo(padX, h - padY);
      ctx.lineTo(padX, padY);
      ctx.stroke();

      const tickFreqs = getTickFrequencies(minFreq, maxFreq);

      // vertikale Gitterlinien an Tick-Frequenzen
      ctx.strokeStyle = "#eee";
      ctx.lineWidth = 1;
      tickFreqs.forEach(f => {
        const fracX = freqToFrac(f, minFreq, maxFreq);
        const x = padX + fracX * plotW;
        ctx.beginPath();
        ctx.moveTo(x, padY);
        ctx.lineTo(x, h - padY);
        ctx.stroke();
      });

      if (maxMag > 0 && plotW > 0) {
        ctx.strokeStyle = "#0077cc";
        ctx.lineWidth = 1;
        ctx.beginPath();

        const steps = plotW;

        for (let i = 0; i < steps; i++) {
          // Frequenzbereich, der auf diesen Pixel abgebildet wird
          const fracStart = i / steps;
          const fracEnd   = (i + 1) / steps;
          let fStart = fracToFreq(fracStart, minFreq, maxFreq);
          let fEnd   = fracToFreq(fracEnd,   minFreq, maxFreq);
          if (fEnd < fStart) { const tmp = fStart; fStart = fEnd; fEnd = tmp; }

          // in Bin-Indizes umrechnen
          let binStart = Math.floor(fStart * N / sr);
          let binEnd   = Math.floor(fEnd   * N / sr);

          if (binStart < minBin) binStart = minBin;
          if (binEnd   > maxBin) binEnd   = maxBin;
          if (binEnd < binStart) binEnd = binStart; // mindestens ein Bin

          // Maximum in diesem Frequenzintervall
          let mag = 0;
          for (let k = binStart; k <= binEnd; k++) {
            const m = magnitudes[k];
            if (m > mag) mag = m;
          }
          if (mag <= 0) mag = 1e-6;

          let norm = mag / maxMag;
          if (norm < 1e-6) norm = 1e-6;
          let db = 20 * Math.log10(norm);
          if (db < MIN_DB) db = MIN_DB;
          const yNorm = (db - MIN_DB) / (0 - MIN_DB);

          const fracMid = (i + 0.5) / steps;    // Mitte des Pixels
          const x = padX + fracMid * plotW;
          const y = (h - padY) - yNorm * plotH;

          if (i === 0) ctx.moveTo(x, y);
          else         ctx.lineTo(x, y);
        }

        ctx.stroke();

        // Peaks als Punkte
        if (peaksList.length > 0) {
          ctx.fillStyle = "#d9534f";
          peaksList.forEach(p => {
            const fracX = freqToFrac(p.freq, minFreq, maxFreq);
            const x = padX + fracX * plotW;
            let norm = p.mag / maxMag;
            if (norm < 1e-6) norm = 1e-6;
            let db = 20 * Math.log10(norm);
            if (db < MIN_DB) db = MIN_DB;
            const yNorm = (db - MIN_DB) / (0 - MIN_DB);
            const y = (h - padY) - yNorm * plotH;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, 2 * Math.PI);
            ctx.fill();
          });
        }

        // Cursor-Linie für aktuellen Peak
        if (currentPeakIndex >= 0 && peaksList[currentPeakIndex]) {
          const p = peaksList[currentPeakIndex];
          const fracX = freqToFrac(p.freq, minFreq, maxFreq);
          const x = padX + fracX * plotW;
          ctx.strokeStyle = "#ff9900";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, padY);
          ctx.lineTo(x, h - padY);
          ctx.stroke();
        }
      }

      // x-Achsen-Beschriftung: Ticks
      ctx.fillStyle = "#555";
      ctx.font = "10px system-ui";
      ctx.textAlign = "center";
      let lastLabelX = -Infinity;
      tickFreqs.forEach(f => {
        const fracX = freqToFrac(f, minFreq, maxFreq);
        const x = padX + fracX * plotW;
        // Labels nicht zu dicht nebeneinander & nicht direkt an den Rand
        if (x - lastLabelX < 35) return;
        if (x < padX + 15) return;
        if (x > padX + plotW - 15) return;
        ctx.fillText(formatHzLabel(f), x, h - 4);
        lastLabelX = x;
      });

      // Min/Max-Beschriftung
      ctx.font = "11px system-ui";
      ctx.textAlign = "left";
      ctx.fillText(`${minFreq.toFixed(0)} Hz`, padX, h - 4);
      ctx.textAlign = "right";
      ctx.fillText(`${maxFreq.toFixed(0)} Hz`, padX + plotW, h - 4);
      ctx.textAlign = "left";
    }

    function selectPeak(idx) {
      if (!peaksList.length) return;
      if (idx < 0) idx = 0;
      if (idx >= peaksList.length) idx = peaksList.length - 1;
      currentPeakIndex = idx;
      updatePeakInfo();
      drawSpectrum();
      prevPeakBtn.disabled = peaksList.length <= 1;
      nextPeakBtn.disabled = peaksList.length <= 1;
    }

    function updatePeakInfo() {
      if (!peaksList.length || currentPeakIndex < 0) {
        peakInfoEl.textContent = "Keine Peaks.";
        return;
      }
      const p = peaksList[currentPeakIndex];
      peakInfoEl.textContent =
        `Peak ${currentPeakIndex + 1} von ${peaksList.length}: ` +
        `f = ${p.freq.toFixed(1)} Hz, rel. Amplitude = ${p.relAmp.toFixed(3)}`;
    }

    function handleCanvasClick(ev) {
      if (!spectrumData || !peaksList.length) return;

      const rect = spectrumCanvas.getBoundingClientRect();
      const xClick = ev.clientX - rect.left;

      const { minFreq, maxFreq } = spectrumData;
      const padX = 40;
      const plotW = spectrumCanvas.width - 2 * padX;

      let frac = (xClick - padX) / plotW;
      const freqClick = fracToFreq(frac, minFreq, maxFreq);

      // Nächstgelegenen Peak zur Klickfrequenz finden
      let bestIdx = 0;
      let bestDist = Infinity;
      peaksList.forEach((p, idx) => {
        const d = Math.abs(p.freq - freqClick);
        if (d < bestDist) {
          bestDist = d;
          bestIdx = idx;
        }
      });

      selectPeak(bestIdx);
    }

    // Radix-2-FFT
    function fft(real, imag) {
      const n = real.length;
      if (n !== imag.length) {
        throw new Error("Real- und Imaginärteil müssen gleiche Länge haben.");
      }
      const levels = Math.log2(n);
      if (Math.floor(levels) !== levels) {
        throw new Error("Länge ist keine Zweierpotenz.");
      }

      for (let i = 0, j = 0; i < n; i++) {
        if (j > i) {
          let t = real[i]; real[i] = real[j]; real[j] = t;
          t = imag[i]; imag[i] = imag[j]; imag[j] = t;
        }
        let m = n >> 1;
        while (m >= 1 && (j & m)) {
          j ^= m;
          m >>= 1;
        }
        j |= m;
      }

      for (let size = 2; size <= n; size <<= 1) {
        const halfSize = size >> 1;
        const phaseStep = -2 * Math.PI / size;
        for (let i = 0; i < n; i += size) {
          for (let j = 0; j < halfSize; j++) {
            const k = i + j;
            const l = k + halfSize;
            const angle = phaseStep * j;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const tre = real[l] * cos - imag[l] * sin;
            const tim = real[l] * sin + imag[l] * cos;
            real[l] = real[k] - tre;
            imag[l] = imag[k] - tim;
            real[k] += tre;
            imag[k] += tim;
          }
        }
      }
    }

    drawEmptySpectrum();
  </script>
</body>
</html>
